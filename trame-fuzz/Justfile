list:
    just --list

afl_target := "target-afl"
main_bin := afl_target + "/debug/trame-fuzz"
vshape_bin := afl_target + "/debug/vshape"
solver_bin := afl_target + "/debug/solver"
solver_in := env_var_or_default("TRAME_SOLVER_IN", "in-solver")
solver_out := env_var_or_default("TRAME_SOLVER_OUT", "out-solver")

# Build and run the fuzzer with SAND (decoupled sanitizers)
fuzz: build
    cargo afl fuzz -m none -i in -o out \
        -w {{ main_bin }}-asan \
        -w {{ main_bin }}-msan \
        -- {{ main_bin }}

# Build and run the VShape fuzzer (LRuntime + VShapeView)
fuzz-vshape: build-vshape
    cargo afl fuzz -m none -i in-vshape -o out-vshape \
        -w {{ vshape_bin }}-asan \
        -w {{ vshape_bin }}-msan \
        -- {{ vshape_bin }}

# Build and run the solver fuzzer (flatten key routing and schema solving)
fuzz-solver: build-solver
    AFL_FORKSRV_INIT_TMOUT=10000 cargo afl fuzz -m none -i {{ solver_in }} -o {{ solver_out }} \
        -- {{ solver_bin }}

# Build and run the solver fuzzer with both ASAN and MSAN workers
fuzz-solver-sand: build-solver
    AFL_FORKSRV_INIT_TMOUT=10000 cargo afl fuzz -m none -i {{ solver_in }} -o {{ solver_out }} \
        -w {{ solver_bin }}-asan \
        -w {{ solver_bin }}-msan \
        -- {{ solver_bin }}

# Build all binaries: native + sanitizer variants
build: build-native build-asan build-msan

# Build native binary (no sanitizers, full speed)
build-native:
    CARGO_TARGET_DIR={{ afl_target }} cargo afl build

# Build with AddressSanitizer + UBSan
build-asan:
    CARGO_TARGET_DIR={{ afl_target }} AFL_LLVM_ONLY_FSRV=1 AFL_USE_ASAN=1 AFL_USE_UBSAN=1 cargo afl build
    cp {{ main_bin }} {{ main_bin }}-asan

# Build with MemorySanitizer
build-msan:
    CARGO_TARGET_DIR={{ afl_target }} AFL_LLVM_ONLY_FSRV=1 AFL_USE_MSAN=1 cargo afl build
    cp {{ main_bin }} {{ main_bin }}-msan

# Build all VShape binaries: native + sanitizer variants
build-vshape: build-vshape-native build-vshape-asan build-vshape-msan

# Build all solver binaries: native + sanitizer variants
build-solver: build-solver-native build-solver-asan build-solver-msan

# Build VShape native binary (no sanitizers, full speed)
build-vshape-native:
    CARGO_TARGET_DIR={{ afl_target }} cargo afl build --bin vshape

# Build VShape with AddressSanitizer + UBSan
build-vshape-asan:
    CARGO_TARGET_DIR={{ afl_target }} AFL_LLVM_ONLY_FSRV=1 AFL_USE_ASAN=1 AFL_USE_UBSAN=1 cargo afl build --bin vshape
    cp {{ vshape_bin }} {{ vshape_bin }}-asan

# Build VShape with MemorySanitizer
build-vshape-msan:
    CARGO_TARGET_DIR={{ afl_target }} AFL_LLVM_ONLY_FSRV=1 AFL_USE_MSAN=1 cargo afl build --bin vshape
    cp {{ vshape_bin }} {{ vshape_bin }}-msan

# Build solver native binary (no sanitizers, full speed)
build-solver-native:
    CARGO_TARGET_DIR={{ afl_target }} cargo afl build --bin solver

# Build solver with AddressSanitizer + UBSan
build-solver-asan:
    CARGO_TARGET_DIR={{ afl_target }} AFL_LLVM_ONLY_FSRV=1 AFL_USE_ASAN=1 AFL_USE_UBSAN=1 cargo afl build --bin solver
    cp {{ solver_bin }} {{ solver_bin }}-asan

# Build solver with MemorySanitizer
build-solver-msan:
    CARGO_TARGET_DIR={{ afl_target }} AFL_LLVM_ONLY_FSRV=1 AFL_USE_MSAN=1 cargo afl build --bin solver
    cp {{ solver_bin }} {{ solver_bin }}-msan

# Resume fuzzing from previous state
resume: build
    cargo afl fuzz -m none -i- -o out \
        -w {{ main_bin }}-asan \
        -w {{ main_bin }}-msan \
        -- {{ main_bin }}

# Resume VShape fuzzing from previous state
resume-vshape: build-vshape
    cargo afl fuzz -m none -i- -o out-vshape \
        -w {{ vshape_bin }}-asan \
        -w {{ vshape_bin }}-msan \
        -- {{ vshape_bin }}

# Resume solver fuzzing from previous state
resume-solver: build-solver
    AFL_FORKSRV_INIT_TMOUT=10000 cargo afl fuzz -m none -i- -o {{ solver_out }} \
        -- {{ solver_bin }}

# Resume solver fuzzing with both ASAN and MSAN workers
resume-solver-sand: build-solver
    AFL_FORKSRV_INIT_TMOUT=10000 cargo afl fuzz -m none -i- -o {{ solver_out }} \
        -w {{ solver_bin }}-asan \
        -w {{ solver_bin }}-msan \
        -- {{ solver_bin }}

# Build standalone binary (for reproducing crashes, running under Miri, etc.)
build-standalone:
    cargo build --features standalone --target-dir target-standalone

# Run a single input file (standalone mode)
run file: build-standalone
    target-standalone/debug/trame-fuzz < {{ file }}

# Run with backtrace
run-bt file: build-standalone
    RUST_BACKTRACE=1 target-standalone/debug/trame-fuzz < {{ file }}

# Run VShape target from a single input file (standalone mode)
run-vshape file:
    cargo build --features standalone --bin vshape --target-dir target-standalone
    target-standalone/debug/vshape < {{ file }}

# Run VShape with backtrace
run-vshape-bt file:
    cargo build --features standalone --bin vshape --target-dir target-standalone
    RUST_BACKTRACE=1 target-standalone/debug/vshape < {{ file }}

# Run solver target from a single input file (standalone mode)
run-solver file:
    cargo build --features standalone --bin solver --target-dir target-standalone
    target-standalone/debug/solver < {{ file }}

# Run solver target with backtrace
run-solver-bt file:
    cargo build --features standalone --bin solver --target-dir target-standalone
    RUST_BACKTRACE=1 target-standalone/debug/solver < {{ file }}

# Run under Miri
run-miri file:
    MIRIFLAGS="-Zmiri-disable-isolation" cargo +nightly miri run --features standalone --target-dir target-miri < {{ file }}

# Minimize a crash input
minimize file:
    cargo afl tmin -i {{ file }} -o minimized.bin -- {{ main_bin }}
    @echo "Minimized input saved to minimized.bin"

# Minimize a VShape crash input
minimize-vshape file:
    cargo afl tmin -i {{ file }} -o minimized-vshape.bin -- {{ vshape_bin }}
    @echo "Minimized input saved to minimized-vshape.bin"

# Minimize a solver crash input
minimize-solver file:
    cargo afl tmin -i {{ file }} -o minimized-solver.bin -- {{ solver_bin }}
    @echo "Minimized input saved to minimized-solver.bin"

# List all crashes
crashes:
    @ls -la out/default/crashes/ 2>/dev/null || echo "No crashes yet"

# Reproduce all crashes with standalone binary and show unique panic lines.
# Usage: just reproduce-all [timeout_secs]
reproduce-all timeout_secs="5":
    #!/usr/bin/env -S bash -euo pipefail
    cargo build --features standalone --bin trame-fuzz --target-dir target-standalone >/dev/null
    if ! compgen -G "out/default/crashes/id:*" > /dev/null; then
        echo "No crashes yet"
        exit 0
    fi
    for f in out/default/crashes/id:*; do
        out="$(timeout "{{ timeout_secs }}" target-standalone/debug/trame-fuzz < "$f" 2>&1 || true)"
        printf '%s\n' "$out" | rg -m1 "^thread 'main' panicked at" || true
    done | sort -u

# Triage crash corpus with exit-code buckets and one-line signatures.
# Usage: just triage-crashes [timeout_secs]
triage-crashes timeout_secs="5":
    #!/usr/bin/env -S bash -euo pipefail
    cargo build --features standalone --bin trame-fuzz --target-dir target-standalone >/dev/null
    if ! compgen -G "out/default/crashes/id:*" > /dev/null; then
        echo "No crashes yet"
        exit 0
    fi
    tmp="$(mktemp)"
    for f in out/default/crashes/id:*; do
        set +e
        out="$(timeout "{{ timeout_secs }}" target-standalone/debug/trame-fuzz < "$f" 2>&1)"
        code=$?
        set -e
        sig="$(printf '%s\n' "$out" | rg -m1 "^thread 'main' panicked at" || true)"
        [ -z "$sig" ] && sig="(no panic line)"
        printf '%s\t%s\t%s\n' "$code" "$sig" "$f" >> "$tmp"
    done
    echo "Exit code histogram:"
    cut -f1 "$tmp" | sort | uniq -c | sed 's/^ *//'
    echo
    echo "Sample signatures:"
    cut -f2 "$tmp" | sort | uniq -c | sort -nr | sed -n '1,20p'

# Deep triage: store per-crash stderr and summarize first failure line.
# Useful when crashes are hard aborts (e.g. exit 133) with no panic line.
# Usage: just triage-crashes-deep [timeout_secs]
triage-crashes-deep timeout_secs="5":
    #!/usr/bin/env -S bash -euo pipefail
    cargo build --features standalone --bin trame-fuzz --target-dir target-standalone >/dev/null
    if ! compgen -G "out/default/crashes/id:*" > /dev/null; then
        echo "No crashes yet"
        exit 0
    fi
    rm -rf triage-logs
    mkdir -p triage-logs
    summary="triage-logs/summary.tsv"
    : > "$summary"
    for f in out/default/crashes/id:*; do
        base="$(basename "$f" | tr ':,/' '_')"
        log="triage-logs/${base}.log"
        set +e
        timeout "{{ timeout_secs }}" env RUST_BACKTRACE=full target-standalone/debug/trame-fuzz < "$f" >"$log" 2>&1
        code=$?
        set -e
        first="$(rg -m1 "panicked at|assertion failed|SIG[A-Z]+|AddressSanitizer|UBSAN|runtime error|memory|segmentation fault|trap|aborted" "$log" || true)"
        [ -z "$first" ] && first="(no marker line)"
        printf '%s\t%s\t%s\t%s\n' "$code" "$first" "$f" "$log" >> "$summary"
    done
    echo "Exit code histogram:"
    cut -f1 "$summary" | sort | uniq -c | sed 's/^ *//'
    echo
    echo "Top markers:"
    cut -f2 "$summary" | sort | uniq -c | sort -nr | sed -n '1,20p'
    echo
    echo "Wrote per-crash logs to triage-logs/"

# Show AFL edge coverage from the corpus
edges: build-native
    cargo afl showmap -C -i out/default/queue -o /dev/stdout -- {{ afl_target }}/debug/trame-fuzz

# Show AFL edge coverage from the solver corpus
edges-solver: build-solver-native
    cargo afl showmap -C -i {{ solver_out }}/default/queue -o /dev/stdout -- {{ afl_target }}/debug/solver

# Build with LLVM source coverage (standalone binary with instrumentation)
build-cov:
    CARGO_INCREMENTAL=0 RUSTFLAGS="-C instrument-coverage" cargo build --features standalone --target-dir target-cov

# Generate source coverage report from corpus
# Usage: just cov [format]

# Formats: report (default), html, uncovered
cov format="report": build-cov
    #!/usr/bin/env -S bash -euo pipefail
    rm -f *.profraw default.profdata
    files=(out/default/queue/*)
    total=${#files[@]}
    i=0
    for f in "${files[@]}"; do
        i=$((i + 1))
        printf "\r%d/%d" "$i" "$total"
        target-cov/debug/trame-fuzz < "$f" 2>/dev/null || true
    done
    echo
    llvm-profdata merge -sparse *.profraw -o default.profdata
    ignore='/.cargo/|/rustc/|afl/src|/facet-(core|macro|macros|reflect[^2])'
    if [ "{{ format }}" = "html" ]; then
        llvm-cov show target-cov/debug/trame-fuzz \
            --instr-profile=default.profdata \
            --ignore-filename-regex="$ignore" \
            --format=html --output-dir=coverage
        echo "Coverage report written to coverage/"
        open coverage/index.html 2>/dev/null || true
    elif [ "{{ format }}" = "uncovered" ]; then
        llvm-cov show target-cov/debug/trame-fuzz \
            --instr-profile=default.profdata \
            --ignore-filename-regex="$ignore" \
            --show-line-counts-or-regions \
            --format=text \
            | awk '/\|[[:space:]]+0\|/'
    else
        llvm-cov report target-cov/debug/trame-fuzz \
            --instr-profile=default.profdata \
            --ignore-filename-regex="$ignore"
    fi
    rm -f *.profraw default.profdata

# Clean build artifacts and output
clean:
    rm -rf target target-afl target-standalone target-cov target-miri out out-vshape out-solver out-solver2 minimized.bin minimized-vshape.bin minimized-solver.bin coverage
